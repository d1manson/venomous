<!--
CUSTOM ELEMENT: venomous-explorer
BY: DM, but all the hard work is from [github.com/cpettitt/dagre-d3]


There are two main psuedo-classes in use here: vnodes and vedges.
vnode:
	name - string, is the text displayed
	left, top - raw values in svg pixels
	node_type - string such as "input" or "compute"
	edges_before, edges_after - arrays, with references to vedges

vedge:
	node1_name, node2_name - strings matching vnode.name
	node1_left, node1_top, node2_left, node2_top - values in svg pixels kept up to date by _vnodes_changed listener


USEAGE:
    <venomous-explorer id="my_graph"></venomous-explorer>
    <script>
        document.getElementById('my_graph').Render(nodeList);
	</script>


	Some things I had to consult for various not-so-obvious bits and bobs...

	repating template details..
	https://github.com/Polymer/polymer/issues/1758 

	css binding...
	http://stackoverflow.com/a/30541458/2399799

	svg/template...
	http://stackoverflow.com/a/30821159/2399799
-->



<dom-module id="venomous-node">
   <link rel="import" href="bower_components/paper-card/paper-card.html">
   <link rel="import" href="bower_components/iron-icons/iron-icons.html">
   <link rel="import" href="bower_components/iron-icons/device-icons.html">
   <link rel="import" href="bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

   <style>
    :host{
   		position: absolute;
   	}
	.card{
		min-width: 80px;
		padding: 4px;
		font-family: 'Roboto', 'Noto', sans-serif;
		background-color: #fff;
	}
	:host[is_moving] .card{
		cursor: move;
	}
	:host[is_selected] .card{
		background-color: #ffc;
	}
	.node_name{	
		vertical-align: bottom;
    	font-weight: bold;
	}
	.card_name{
		text-align: center;
	}
	ul{
		margin: 0px;
		list-style-position: inside;
		font-size: 0.8em;
		line-height: initial;
    	padding-left: 0px;
	    list-style-type: none;
	}
	li{
		border: 1px solid #ccc;
		margin-bottom: 2px;
		padding-left: 4px;
		padding-right: 4px;
	}
   </style>

	<template>
	<paper-material class="card" style$="[[node_type_to_css(node_type)]]" elevation$="[[elevation]]">
		<div class="card_top">
		<iron-icon icon="[[node_type_to_icon(node_type)]]"></iron-icon>
		<span class="node_name">[[name]]</span>
		</div>
		<ul><template is="dom-repeat" items="{{aliases}}">
			<li class="alias_name">{{item.name}}</li>
		</template></ul>
	</paper-material>
	</template>

	<script>
	"use strict";
  	
	var node_type_to_icon_mapping = {
  	input: 'icons:system-update-alt',
  	compute: 'hardware:laptop',
  	loop: 'icons:autorenew'
	}
	var node_type_to_css_mapping = {
	  	input: 'color:#99f',
	  	compute: 'color:#cc7',
	  	loop: 'color:#1FB31F'
	}

	// element registration
    Polymer({
      is: "venomous-node",
      get_elevation: function(is_selected){
      	return is_selected  ? 5 : 2;
      },
      behaviors: [
      	Polymer.IronResizableBehavior
      ],
      listeners: {
      	track: '_on_track',
      	'iron-resize': '_on_resize'
      },
      properties: {
  		name: {type: String,
  			observer: '_contents_changed'},
  		node_type: {type: String,
  			observer: '_contents_changed'},
  		is_moving: {type: Boolean,
  				value: false,
  				reflectToAttribute: true,
  				notify: true},
  		is_selected: {type: Boolean,
  			value: false,
  			reflectToAttribute: true},
  		left: {type: Number,
  				value: 0,
  				observer: '_pos_changed',
  				notify: true},
  		top: {type: Number,
  			  value: 0,
   			  observer: '_pos_changed',
   			  notify: true},
   		origin_x: {type: Number,
   					value: 0,
	   				observer: '_pos_changed',},
   		origin_y: {type: Number,
   					value: 0,
   					observer: '_pos_changed',},
   		width: {type: Number,
   				value: 0,
   				notify: true,
   				readOnly: true},
   		height: {type: Number,
   				value: 0,
   				notify: true,
   				readOnly: true},
   		aliases: {type: Array,
   				  value: function(){return [];},
   			      observer: '_contents_changed'},
   	    elevation: {type: Number,
   	    		value: 2,
   	    	    computed: 'get_elevation(is_selected)',
   	    		notify: true}
      },
      _on_resize: function(e){
		// I'm not sure why this has to be async
		// I opened an issue here: https://github.com/PolymerElements/iron-resizable-behavior/issues/7
      	var el = e.currentTarget;
      	this.debounce('update_size', function(){
	      	this._setWidth(el.clientWidth);
	      	this._setHeight(el.clientHeight);
	    }, 1)
      },
      _on_track: function(e){
        switch(e.detail.state) {
          case 'start':
            this.set("is_moving",true)
            break;
          case 'track':
            this.set('left',this.left + e.detail.ddx);
            this.set('top', this.top + e.detail.ddy);
            break;
          case 'end':
            this.set("is_moving",false)
            break;
        }
        e.stopPropagation(); // prevent dragging on main zone too.
      },
      _contents_changed: function(){
      	this.notifyResize();
      },
      _pos_changed: function(){
      	this.style.left = (this.left + this.origin_x) + "px";
      	this.style.top = (this.top + this.origin_y) + "px";
		this.notifyResize();
      },
      node_type_to_icon(node_type){
      	return node_type_to_icon_mapping[node_type];
      },
      node_type_to_css(node_type){
		return node_type_to_css_mapping[node_type];
      }
    });
	</script>
</dom-module>

<dom-module id="venomous-loop">
<style type="text/css">
	:host{
		position: absolute;
		box-shadow: inset 0px 0px 80px 80px rgba(0,255,0,0.1);
		-webkit-box-shadow: inset 0px 0px 80px 80px rgba(0,255,0,0.1);
		-moz-box-shadow: inset 0px 0px 80px 80px rgba(0,255,0,0.1);
		-o-box-shadow: inset 0px 0px 80px 80px rgba(0,255,0,0.1);
	    overflow: hidden;
	    border: 1px solid #1FB31F;
	}
	:host[is_moving]{
		cursor: move;
	}
	:host[is_selected]{
		box-shadow: none;
		-webkit-box-shadow: none;
		-moz-box-shadow: none;
		-o-box-shadow: none;
		box-shadow: inset 0px 0px 80px 80px #ffc;
		-webkit-box-shadow: inset 0px 0px 80px 80px #ffc;
		-moz-box-shadow: inset 0px 0px 80px 80px #ffc;
		-o-box-shadow: inset 0px 0px 80px 80px #ffc;
	}
	.bar{
		background-color: #1FB31F;
		position: absolute;
		display: none;
	}
	.zone{
		position: absolute;
		cursor: move;
	}
	:host[is_selected] .bar{
		display: block;
	}
	.left.bar,
	.right.bar{
		width: 5px;
		cursor: ew-resize;
	}
	.top.bar,
	.bottom.bar{
		height: 5px;
		cursor: ns-resize;
	}
	.left.zone,
	.right.zone{
		width: 50px;
	}
	.top.zone,
	.bottom.zone{
		height: 50px;
	}
	.left{
		left: 0px;
		top: 0px;
		height: 100%;
	}
	.right{
		right: 0px;
		top: 0px;
		height: 100%;
	}
	.top{
		left: 0px;
		top: 0px;
		width: 100%;
	}
	.bottom{
		bottom: 0px;
		width: 100%;
		left: 0px;	
	}
	.name_text{
		color: #1FB31F;
		font-weight: bold;
		font-family: 'Roboto', 'Noto', sans-serif;
		position: absolute;
		text-align: left;
		top: 10px;
		left: 10px;
	}
</style>
<template>
	<div class="left zone" on-track="_on_drag" bar_duty="centre"></div>
	<div class="right zone" on-track="_on_drag" bar_duty="centre"></div>
	<div class="top zone" on-track="_on_drag" bar_duty="centre"></div>
	<div class="bottom zone" on-track="_on_drag" bar_duty="centre"></div>

	<content>
		
	</content>	
	<div class="left bar" on-track="_on_drag" bar_duty="left"></div>
	<div class="right bar" on-track="_on_drag" bar_duty="right"></div>
	<div class="top bar" on-track="_on_drag" bar_duty="top"></div>
	<div class="bottom bar" on-track="_on_drag" bar_duty="bottom"></div>

</template>
<script>

	Polymer({
		is: 'venomous-loop',
		properties: {
			width: {
				type: Number,
				notify: true,
				value: 100,
				observer: '_sizeChanged'
			},
			height: {
				type: Number,
				notify: true,
				value: 100,
				observer: '_sizeChanged'
			},
			left: {
				type: Number,
				notify: true,
				value: 0,
				observer: '_sizeChanged'
			},
			top: {
				type: Number,
				notify: true,
				value: 0,
				observer: '_sizeChanged'
			},
			origin_x: {type: Number,
   					value: 0,
				observer: '_sizeChanged'},
   			origin_y: {type: Number,
   					value: 0,
				observer: '_sizeChanged'},
			is_moving:{
				type: Boolean,
				reflectToAttribute: true,
				default: false,
				notify: true
			},
			name: {
				type: String
			},
			is_selected: {
				type: Boolean,
				notify: true,
				reflectToAttribute: true,
				default: false
			}
		},
		_sizeChanged: function(e){
			this.style.width = this.width + "px";
			this.style.height = this.height + "px";
			this.style.left = (this.left + this.origin_x) + "px";
			this.style.top = (this.top + this.origin_y) + "px";
		},
		_on_drag: function(e){
			var duty = e.currentTarget.getAttribute('bar_duty');
			switch(e.detail.state) {
	          case 'start':
	          	if(duty == "centre")
	          		this.set('is_moving', true)
	            break;
	          case 'track':
	          	if(duty == 'right'){
	          		this.set('width', this.width + e.detail.ddx);
	          	}else if(duty == 'bottom'){
	          		this.set('height', this.height + e.detail.ddy);
	          	}else if(duty == 'left'){
	          		this.set('width', this.width - e.detail.ddx);
	          		this.set('left', this.left + e.detail.ddx);
	          	}else if(duty == 'top'){
	          		this.set('height', this.height - e.detail.ddy);
	          		this.set('top', this.top + e.detail.ddy);
	          	}else{ //centre
	          		this.set('left', this.left + e.detail.ddx);
	          		this.set('top', this.top + e.detail.ddy);
	          	}
	            break;
	          case 'end':
  	          	if(duty == "centre")
	          		this.set('is_moving', false)
	            break;
	        }
	        e.stopPropagation(); // prevent dragging on main zone too.
		}

	});
</script>
</dom-module>

<dom-module id="venomous-explorer">
   <link rel="import" href="bower_components/iron-flex-layout/classes/iron-flex-layout.html">
  <style>

	#main_zone{
	overflow-x: hidden;
	overflow-y: hidden;
	cursor: default;
    padding: 8px;
    height: 10000%;
    width:1000%;
    position:absolute;
    top:0px;
    left: 0px;
    z-index: 0;
	border: 10px solid #f00;
	}
	#grid_pattern{
	position: absolute;
	top: 0px;
	left: 0px;
	height: 100%;
	width: 100%;
	z-index: -4;
    background-size: 25px 25px;    
    background-color: #fafafa;
    background-image:repeating-linear-gradient(0deg, #ccc, #ccc 1px, transparent 1px, transparent 25px),
    				 repeating-linear-gradient(-90deg, #ccc, #ccc 1px, transparent 1px, transparent 25px);    
	}
	::-webkit-scrollbar {
	width: 10px;
	height: 10px;
	}
	::-webkit-scrollbar-button {
	width: 0;
	height: 0;
	display: none;
	}
	::-webkit-scrollbar-thumb {
	background-color: rgba(0,0,0,0.2);
	-webkit-box-shadow: inset 1px 1px 0 rgba(0,0,0,0.10),inset 0 -1px 0 rgba(0,0,0,0.07);
	}
	.edge{
		position: absolute;
		top: 0px;
		left: 0px;
		width: 100%;
		height: 100%;
	}
	.noselect {
	  -webkit-touch-callout: none;
	  -webkit-user-select: none;
	  -khtml-user-select: none;
	  -moz-user-select: none;
	  -ms-user-select: none;
	  user-select: none;
	}
	#about{
		position: absolute;
		right: 10px;
		top:5px;
		text-align: right;
		color: #999;
		font-family: 'Roboto', 'Noto', sans-serif;
	}
	:host[is_moving] #main_zone{
		cursor: move;
	}
  </style>
  
  <template>
  	<div id="container" class="layout vertical" style="height:100%;">
  		<div id="grid_pattern"></div>
  		<div id="about" class="noselect">venomous explorer</div>
	    <div id='main_zone' class="noselect"
	     on-track="main_zone_on_track" 
	     on-tap="node_on_click" nodrag>	

	     	<!-- it would  be nice to have on svg node, and put the template inside it, but this is only possible with Polymer 0.5 not 1.0-->
	    	<template is="dom-repeat" items="[[vedges]]">    	
		    	<svg class="edge">
		    	  <defs>
				    <marker id="arrow" markerWidth="10" markerHeight="10" refx="9" refy="3" orient="auto" markerUnits="strokeWidth">
				      <path d="M0,0 L0,6 L9,3 z" fill="#000" />
				    </marker>
				  </defs>

		    		<line x1$="[[get_edge_xy('x1', item.*)]]" x2$="[[get_edge_xy('x2', item.*)]]" 
		    		  y1$="[[get_edge_xy('y1', item.*)]]" y2$="[[get_edge_xy('y2', item.*)]]"
		    		  style="stroke:rgb(0,0,0);stroke-width:1" marker-end="url(#arrow)"/>
		    	</svg>
	    	</template>
	    	
	    	<template is="dom-repeat" items="{{vnodes}}">
				<venomous-node 
				   index$="[[index]]" 
				   on-tap="node_on_click"
				   is_moving="{{item.is_moving}}"
				   origin_x="[[origin_x]]" origin_y="[[origin_y]]"
				   left="{{item.left}}" top="{{item.top}}"
				   width="{{item.width}}" height="{{item.height}}"
				   name="[[item.name]]" node_type="[[item.node_type]]"
				   aliases="[[item.aliases]]"
				   is_selected="[[item.is_selected]]"></venomous-node>
			</template>

			<template is="dom-repeat" items="{{vloops}}">
			<venomous-loop index$="[[index]]" name="[[item.name]]" 
  			    origin_x="[[origin_x]]" origin_y="[[origin_y]]"
				left="{{item.left}}" top="{{item.top}}" width="{{item.width}}" height="{{item.height}}"
				index$="[[index]]"	on-tap="node_on_click" is_selected="[[item.is_selected]]">

		    	<template is="dom-repeat" items="{{item.vnodes}}" as="jtem">
					<venomous-node
					   index$="[[index]]" 
					   on-tap="node_on_click"
					   is_moving="{{jtem.is_moving}}"
					   left="{{jtem.left}}" top="{{jtem.top}}"
					   width="{{jtem.width}}" height="{{jtem.height}}"
					   name="[[jtem.name]]" node_type="[[jtem.node_type]]"
					   aliases="[[jtem.aliases]]"
					   is_selected="[[jtem.is_selected]]"></venomous-node>
				</template>


			</venomous-loop>
	    	</template>

	    </div>
	</div>
  </template>


  <script type="text/javascript" src="bower_components/XMLWriter/XMLWriter.js"></script>
  <script type="text/javascript" src="polyfill_array_find.js"></script>
  <script>
  "use strict";
  

  var push_objs_vals_onto_array = function(arr, obj){
	for(var k in obj)if(obj.hasOwnProperty(k))
	    arr.push(obj[k]);
	return arr;
  }
  var getAttr = function(el,attr){
  	return el.attributes.getNamedItem(attr).value;
  }

  var remove_common_indent = function(s){
		var lines = s.split(/\r?\n/);
		// find minimum common indent on non-empty lines
		var min_indent = s.length; //simple upper bound
		for(var i=0; i<lines.length;i++) {
			var whitespace = lines[i].split(/\S/,1)[0];
			if(whitespace.length < min_indent && whitespace.length != lines[i].length)
				min_indent = whitespace.length;
		}
		// remove indent
		if(min_indent)
			s = lines.map(function(line){return line.substr(min_indent)}).join('\r\n');
		return s;
  }

    // element registration
    // TODO: loops and nodes should be abastracted into a common "base class"-ish thing.....current setup is very messy.
    Polymer({
      is: "venomous-explorer",
      _vnode_idx_from_name: function(n){
      	// it would be easier to store vnodes in a key-value object rather than an array but I don't think you can for template usage
      	return this.vnodes.findIndex(function(v){return v.name == n;});
      },
      _vloop_idx_from_name: function(n){
      	return this.vloops.findIndex(function(v){return v.name == n;});
      },
      get_edge_xy(coord_type, edge){
      		edge = edge.base;
      		if(coord_type == 'x1')
      			return edge.node1_left + 0.5*(edge.node1_width || 0) + this.origin_x;
      		else if(coord_type == 'x2')
      			return edge.node2_left + 0.5*(edge.node2_width || 0) + this.origin_x;
      		else if(coord_type == 'y1')
      			return edge.node1_top + (edge.node1_height || 0) + this.origin_y;
      		else
      			return edge.node2_top + this.origin_y;
      },
      node_on_click: function(e){
		var idx = e.currentTarget.index;
		var clicked_type = e.currentTarget.tagName.toLowerCase() == "venomous-loop" ? "vloop" : "vnode"; // could also be main div (if idx===undefined)

		if(this.active_name){
			var old_idx = this.active_kind == "vnode" ?
							 this._vnode_idx_from_name(this.active_name)
						   : this._vloop_idx_from_name(this.active_name);
			this.set(this.active_kind + 's.' + old_idx + ".is_selected", false);			
		}

		if(idx !== undefined){
			this.set('active_kind', clicked_type)
			this.set(clicked_type + 's.' + idx + ".is_selected", true);
			this.set('active_name', clicked_type == 'vnode' ?
										this.vnodes[idx].name
									  : this.vloops[idx].name);
		}else{
			this.set('active_name', '');
			this.set('active_kind', '');
		}
		e.stopPropagation(); // prevent click on main zone too.
      },
      main_zone_on_track: function(e){
		switch(e.detail.state) {
          case 'start':
            this.set('is_moving',true)
            break;
          case 'track':
            this.set('offset_left', this.offset_left - e.detail.ddx);
            this.set('offset_top', this.offset_top - e.detail.ddy);
            break;
          case 'end':
            this.set("is_moving",false)
            break;
        }      	
      },
      write_to_xml: function(){
      		var xw = new XMLWriter('UTF-8');
			xw.formatting = 'indented';//add indentation and newlines
			xw.indentChar = ' ';//indent with spaces
			xw.indentation = 2;//add 2 spaces per level

			xw.writeStartDocument();
			xw.writeStartElement('document');

			xw.writeStartElement('engine');
			xw.writeXML(this.loaded_engine_xml);
	     	xw.writeEndElement();

			xw.writeStartElement('layout');
			  for(var i=0; i<this.vnodes.length; i++){
			  	var v = this.vnodes[i];
			  	xw.writeStartElement('box')
			    xw.writeAttributeString('name', v.name);
			    xw.writeAttributeString('left', v.left);
			    xw.writeAttributeString('top ', v.top);
			    xw.writeEndElement(); 
			  }
			  
			  for(var i=0; i<this.vloops.length; i++){
			  	var v = this.vloops[i];
			  	xw.writeStartElement('box')
			    xw.writeAttributeString('name', v.name);
			    xw.writeAttributeString('left', v.left);
			    xw.writeAttributeString('top', v.top);
				xw.writeAttributeString('width ', v.width);
				xw.writeAttributeString('height', v.height);
			    xw.writeEndElement(); 
			  }
			  

			  xw.writeStartElement("offset");
			  xw.writeAttributeString("left", this.offset_left);
			  xw.writeAttributeString("top", this.offset_top);

			 xw.writeEndElement(); //layout

			xw.writeEndElement(); //document
			xw.writeEndDocument();

			return xw.flush(); //generate the xml string
      },
      load_from_xml: function(root){
      		console.dir(root);

      		if(root.length != 1 || root[0].nodeName.toLowerCase() != "document")
      			return this.fire('error',{type: 'parse-error', msg: 'the root node should simply by called "document", and cannot have any siblings.'});
      		root = root[0]; // now root really is the root, and contains engine (and layout) children.
			
      		for(var i_engine=0;i_engine<root.childNodes.length && root.childNodes[i_engine].nodeName.toLowerCase() == "#text"; i_engine++)
      			;// find first non-text node

			if(i_engine == root.childNodes.length || root.childNodes[i_engine].nodeName.toLowerCase() != "engine")      		
      			return this.fire('error',{type: 'parse-error', msg: "document should have the engine as its first child."});

      		var engine = root.childNodes[i_engine]; 
			this.loaded_engine_xml = engine.innerHTML;

			var inputs = {};
			var computes = {};
			var aliases = {};
			var loops = {};
			var all_vs = {};
			var edges_ = [];
			for(var i=0;i< engine.childNodes.length; i++){
				var node = engine.childNodes[i];
				var node_name = node.nodeName.toLowerCase(); 
				if(node_name == "input"){
					var v = {name: getAttr(node,"name"),
					 		 node_type: 'input',
					 		 left: 20 + i*5,
					 		 top: 100 + i*5,
					 		 width: 0, height: 0,
					 		 edges_after: [],
					 		 aliases: [],
					 		 description: ''};
					inputs[v.name] = v;
					all_vs[v.name] = v;
					for(var j=0;j<node.childNodes.length; j++){
						var node_j = node.childNodes[j];
						var node_j_name = node_j.nodeName.toLowerCase()
						if(node_j_name == "description"){
							v.description = remove_common_indent(node_j.innerHTML).trim();
						}
					}

				}else if(node_name == "compute"){
					var v = {name: getAttr(node,"name"),
					         node_type: 'compute',
					         left: 20 + i*5,
					         top: 200 + i*5,
 					 		 width: 0, height: 0,
					     	 edges_before: [],
					     	 edges_after: [],
					     	 aliases: [],
					     	 code: '',
					     	 description: ''};
					for(var j=0;j<node.childNodes.length; j++){
						var node_j = node.childNodes[j];
						var node_j_name = node_j.nodeName.toLowerCase()
						if(node_j_name == "arg"){
							var e = {node1_name: getAttr(node_j,"name"),
									 node2_name: v.name };
							if(e.node1_name in aliases){
								aliases[e.node1_name].edges_after.push(e);
							}else if(e.node1_name in all_vs){
								all_vs[e.node1_name].edges_after.push(e);
							}else{
								this.fire('error', {type: 'parse-error', msg: 'could not find arg named "' + e.node1_name + '"'})
								continue;
							}
							v.edges_before.push(e);
							edges_.push(e);
						}else if(node_j_name == "code"){
							for(var k=0;k<node_j.childNodes.length;k++)if(node_j.childNodes[k].nodeName.toLowerCase() == "#cdata-section")
								v.code += node_j.childNodes[k].data;
							v.code = remove_common_indent(v.code).trim();
						}else if(node_j_name == "description"){
							v.description = remove_common_indent(node_j.innerHTML).trim();
						}

					}
					computes[v.name] = v;
					all_vs[v.name] = v;
				}else if(node_name == "alias"){
					var src = all_vs[getAttr(node, 'src')]; 
					var a = {name: getAttr(node, 'name'),
							 src: src
							}
					src.aliases.push(a);
					a.edges_before = src.edges_before; // alias the array TODO: somehting more complciated in the long run
					a.edges_after = src.edges_after; // alias the array
					aliases[a.name] = a;
				}else if(node_name == "loop"){
					var v = {name: getAttr(node, 'name'),
							 top: 0,
							 left: 0,
							 width: 100,
							 height: 100,
							 description: '',
							 vnodes: [{name: 'dummy_delta',
							 	node_type: 'input',
							 	top: 50, left: 300,
							 	width: 0, height: 0, 
							 	code: '', description: ''},
							 	{name: getAttr(node, 'name'),
							 	node_type: 'loop',
							 	top: 50, left: 50,
							 	width: 0, height: 0, 
							 	code: '', description: ''},
							 	{name: 'dummy_state',
							 	node_type: 'compute',
							 	top: 130, left: 200,
							 	width: 0, height: 0, 
							 	code: '', description: 'uses `previous_state` and `dummy_delta` to update for current iteration.'}
							 ]
							};
					for(var j=0;j<node.childNodes.length; j++){
						var node_j = node.childNodes[j];
						var node_j_name = node_j.nodeName.toLowerCase()
					    if(node_j_name == "description"){
							v.description = remove_common_indent(node_j.innerHTML).trim();
						}
					}
					loops[v.name] = v;
				}
			}	

      		for(var i_layout=i_engine+1;i_layout<root.childNodes.length && root.childNodes[i_layout].nodeName.toLowerCase() == "#text"; i_layout++)
      			;// find first non-text node

			if(i_layout < root.childNodes.length){
				if(root.childNodes[i_layout].nodeName.toLowerCase() != "layout")
					return this.fire('error',{type: 'parse-error', msg: 'the document can contain only an "engine" and a "layout" node.'});
				var layout = root.childNodes[i_layout];
				for( var i=0; i< layout.childNodes.length; i++){
					var node = layout.childNodes[i];
					var node_name = node.nodeName.toLowerCase(); 
					if(node_name == "box"){
						var name = getAttr(node,"name");
						if(name in all_vs){
							all_vs[name].left = parseFloat(getAttr(node,"left"));
						    all_vs[name].top = parseFloat(getAttr(node,"top"));	
						}else if(name in loops){
							loops[name].left = parseFloat(getAttr(node,"left"));
							loops[name].top = parseFloat(getAttr(node,"top"));
							loops[name].width = parseFloat(getAttr(node,"width"));
							loops[name].height = parseFloat(getAttr(node,"height"));	
						}
					}else if(node_name == "offset"){
						this.set("offset_left", parseFloat(getAttr(node, "left")));
						this.set("offset_top", parseFloat(getAttr(node, "top")));
					}
				}
			}
			this.set('vedges', edges_);
			this.set('vnodes', 	push_objs_vals_onto_array([], all_vs));
			this.set('vloops', 	push_objs_vals_onto_array([], loops));
			
      		return this.fire('error', {type: 'not-implemented', msg: 'need to actually finish implement parsing.'});
      },
      _vnodes_changed_sub: function(v){
      		// used by _vnodes_changed

      		if(v.edges_before) for(var i=0;i<v.edges_before.length; i++){
      			var e = v.edges_before[i];
				this.set('vedges.' + e.idx + '.node2_left', v.left);
				this.set('vedges.' + e.idx + '.node2_top', v.top);
				this.set('vedges.' + e.idx + '.node2_width', v.width);
				this.set('vedges.' + e.idx + '.node2_height', v.height);
			}
			if(v.edges_after) for(var i=0;i<v.edges_after.length; i++){
				var e = v.edges_after[i];
				this.set('vedges.' + e.idx + '.node1_left', v.left);
				this.set('vedges.' + e.idx + '.node1_top', v.top);
				this.set('vedges.' + e.idx + '.node1_width', v.width);
				this.set('vedges.' + e.idx + '.node1_height', v.height);
			}
      },
      _vnodes_changed: function(delta){
      		/* This is solely responsible for telling edges about the left/top and width/height of their start/end nodes.
				we are essentially implementing a manual binding from start/end node to each of their edges.
      		*/
      		if(delta.path == "vnodes.splices"){
      			delta.indexSplices.forEach(function(delta_sub){
						delta_sub.added.forEach(this._vnodes_changed_sub, this)
						},this)
      		}else if(delta.path == "vnodes"){
      			delta.value.forEach(this._vnodes_changed_sub, this);
      		}else{
      			var v = this.vnodes[parseInt(delta.path.split(".")[1])];
      			this._vnodes_changed_sub(v);
      		}
      },
      _vedges_spliced: function(delta){
      	// this is solely responsible for keeping the edges informed of their own index in the array,
      	// information needed by _vnodes_changed_sub
      	for(var i=0;i<this.vedges.length;i++)
      		this.vedges[i].idx = i; //lazily set it on all..note we dont use "set" here, so no further event listeners are informed
      },
	 _offset_changed: function(){
	 	this.$.main_zone.style.left = -this.offset_left + "px";
		this.$.main_zone.style.top = -this.offset_top + "px";
	 },
	 is_falsy: function(x){
	 	return !x;
	 },
	 lookup_node_key: function(node_name, node_kind, key){
	 	var v = node_kind == "vnode" ? 
	 			 this.vnodes[this._vnode_idx_from_name(node_name)]
	 		   : this.vloops[this._vloop_idx_from_name(node_name)];

	 	return v ? v[key] : "";
	 },
      observers: [
    		'_vnodes_changed(vnodes.*)',
    		'_vedges_spliced(vedges.splices)'
  	  ],
      properties: {
      		vnodes: {type: Array,
      		        value: function() {return [];},
      		        notify: true},
      		vedges: {type: Array,
      		        value: function() {return [];},
      		        notify: true},
      		vloops: {type: Array,
      				value: function() {return [];},
      				notify: true},
      		is_moving: {type: Boolean,
      					value: false,
      				  reflectToAttribute: true},
      		no_node_is_active: {type: Boolean,
      							 value: true,
      							 computed: 'is_falsy(active_name)',
      							 notify: true},
      		active_name: {type: String,
      					value: "",
      					notify: true},
      		active_kind: {type: String,
      					value: '',
      					notify: true},
      		active_code: {type: String,
      					computed: "lookup_node_key(active_name, active_kind, 'code')",
      					value: "",
      					notify: true},
      		active_description: {type: String,
      					computed: "lookup_node_key(active_name, active_kind, 'description')",
      					value: "",
      					notify: true},
      		offset_left: {type: Number,
      					  value: 5000,
      					  notify: true,
      					  observer: '_offset_changed'},
      		offset_top: {type: Number,
      					  value: 5000,
      					  notify: true,
      					  observer: '_offset_changed'},
      		origin_x: {
      			type: Number,
      			value: 5000,
      			readOnly: true
      		},
      		origin_y: {
      			type: Number,
      			value: 5000,
      			readOnly: true
      		}
      }
    });
  </script>

</dom-module>



