

<!DOCTYPE html>
<html style="height:100%;">
  <head>
    <script src="bower_components/webcomponentsjs/webcomponents-lite.js">
    </script>
    <link rel="import" href="bower_components/polymer/polymer.html">
    <link rel="import" href="venomous_explorer.html">
    <title>sample [Venomous Explorer]</title>
  </head>
  <body style="height:100%;margin:0;">
  <venomous-explorer  id="the_graph" style="height:100%;"></venomous-explorer>
  <script>
  window.addEventListener('WebComponentsReady', function(e) {
      var el = document.getElementById("the_graph");
      el.Render([{"class_": "input", "directBefore": [], "name": "axona_file_name", "id": 0}, {"class_": "compute", "directBefore": [0], "code": "const int BLOCK_SIZE = 2*1024*104; //2MB\nFileStreamer f(axona_file_name); //this is C++ RAII in action, we are using axona_file_name from its definition as an \"input\".\nint n_blocks = ceil(f.length()/BLOCK_SIZE); \nif ( !computed(header) ){\n\t// we may already have this cached.\n\tmap header_tmp;\n\t// parse f into header, storing the n_block, and data_start pointer as well\n\theader = header_tmp; \n}\n\nfor (block_ii in requested_blocks){\n\tbuffer[block_ii] = f.read(block_ii*BLOCK_SIZE, BLOCK_SIZE);\n}", "name": "axona_file", "id": 1}, {"class_": "compute", "directBefore": [-1, -1], "code": "used_both = set_file.header['colactive_2']; \n\nint num_samps = parseInt(pos_file.header['num_samps']);\nif (use_both){\n\txy1.allocate(num_samps);\n\txy2.allocate(num_samps);\n\tfor(auto c pos_file.buffer.iter_blocks(16)){\n\t\txy1.write(block[3]); // TODO: actual post processing..this is complicated for a number of reasons.\n\t\txy2.write(block[4]);\n\t}\t\n}else{\n\txy_1.allocate(num_samps);\n\tfor(auto c pos_file.buffer.iter_blocks(16))\n\t\txy1.write(block[3]);\n}\nw1 = sum(!nan(xy1));\nw2 = sum(!nan(xy2));", "name": "both_xy", "id": 2}, {"class_": "compute", "directBefore": [2], "code": "if(!both_xy.used_both){\n\txy = both_xy.xy1;\n}else{\n\txy.allocate(both_xy.xy1.length);\n\tfor(auto p1, p2 : both_xy.xy1, both_xy.xy2)\n\t\txy.write(p1*both_xy.w1 + p2*both_xy.w2);\n}", "name": "xy", "id": 3}, {"class_": "compute", "directBefore": [2, 3, -1], "code": "used_both = both_xy.used_both;\ndir_disp.allocate(xy.length);\nif(used_both){ \n\t// TODO: could check which of the two dirs is requested and do different loop based on that. requested(dir_disp)\n\tdir.allocate(xy.length);\n\tpoint pw_old(nan,nan); \n\tfor(auto p1, p2, pw : both_xy.xy1, both_xy.xy2, xy){\n\t\tdir.write(angle_ab(p1,p2));\n\t\tdir_disp.write(angle_ab(pw,pw_old));\n\t\tpw_old = pw;\t\n\t}\n}else{\n\tdir_disp.allocate(xy.length);\n\tdir.equals(dir_disp);\n\tpoint pw_old(nan,nan); \n\tfor(auto pw : xy){\n\t\tdir_disp.write(angle_ab(pw,pw_old));\n\t\tpw_old = pw;\t\n\t}\n}", "name": "dir", "id": 4}, {"class_": "compute", "directBefore": [3, -1], "code": "int f = parseInt(pos_file.header['timebase']);\nspeed.allocate(xy.length);\npoint p_old (nan,nan);\nfor(auto p : xy){\n\tspeed.write(hypot(p_old.x - p.x, p_old.y - p.y) * f);\n\tp_old = p;\n}", "name": "speed", "id": 5}, {"class_": "input", "directBefore": [], "name": "group_num", "id": 6}, {"class_": "input", "directBefore": [], "name": "trial_time_slice", "id": 7}, {"class_": "input", "directBefore": [], "name": "directional_slice", "id": 8}, {"class_": "input", "directBefore": [], "name": "spatial_mask", "id": 9}, {"class_": "input", "directBefore": [], "name": "boundary_dist_slice", "id": 10}, {"class_": "input", "directBefore": [], "name": "boundary_shape", "id": 11}, {"class_": "compute", "directBefore": [3, 11], "code": "// might want to implement it as dist_to_boundary squared..although that only makes sense for circle not square \n// so the details are a bit more complicated.\ndist_to_boundary.allocate(xy.length);\nif(boundary_shape.kind == circle){\n\tfor(auto p : xy)\n\t\tdist_to_boundary.write( hypot(p.x-boundary_shape.shape.centre.x, p.y-boundary_shape.shape.centre.y));\n}else{ // boundary_shape.kind == rect\n\tfor(auto p : xy)\n\t\tdist_to_boundary.write( boundary_dist_rect(p, boundary_shape.shape.topleft, boundary_shape.shape.W, boundary_shape.shape.H));\n}", "name": "dist_to_boundary", "id": 12}, {"class_": "compute", "directBefore": [-1, 7, 8, 9, 10, 12], "code": "if(!isnull(trial_time_slice)  ||\n   !isnull(directional_slice) ||\n   !isnull(spatial_mask)\t  ||\n   !isnull(boundary_dist_slice)){\n\n   \t   // some kind of masking has been requested\n   \t   if(!computed(mask)){\n\t\t   // we may already have computed mask, (in which case we are supposed to compute summary)\n\t\t   \t   \t   \n\t\t   vector<bool> tmp = array(pos_file.header[\"num_samps\"]);\n\t\t   \n\t\t   if(!isnull(trial_time_slice)){\n\t\t   \t\ttmp[:trial_time_slice.start = False;\n\t\t   \t\ttmp[trial_time_slice.end:] = False;\n\t\t   }\n\n\t\t   if(!isnull(directional_slice)){\n\t\t\t\ttmp[!(directional_slice.start < dir[1] < directional_slice.end)] = False;\n\t\t   }\n\n\t\t   if(!isnull(boundary_dist_slice)){\n\t\t\t\ttmp[!(boundary_dist_slice.start < dist_to_boundary < boundary_dist_slice.end)] = False;\n\t\t   }\n\n\t\t   //TODO: implement spatial mask\n\n\t\t   mask = tmp;\n\n\t   }\n\t   if(requested(summary))\n\t   \t\tsummary = make_logical_summary(mask);\n\n   }else{\n\t   summary = all; //mask is all-true, so don't actually need to make it\n   }", "name": "pos_mask", "id": 13}, {"class_": "compute", "directBefore": [-1, -1], "code": "// read timebases to get factor and apply to spike times", "name": "spike_pos_inds", "id": 14}, {"class_": "compute", "directBefore": [13, 14], "code": "//lookup spike pos inds in pos mask..use sorted_access_iterator", "name": "spike_mask", "id": 15}, {"class_": "input", "directBefore": [], "name": "speed_bin_size", "id": 16}, {"class_": "compute", "directBefore": [5, 13, 16], "code": "if(pos_mask.summary == all)\n\tspeed_dwell = hist(speed, speed_bin_size);\nelse\n\tspeed_dwell = hist_masked(speed, pos_mask, speed_bin_size);", "name": "speed_dwell", "id": 17}, {"class_": "input", "directBefore": [], "name": "spa_bin_size", "id": 18}, {"class_": "compute", "directBefore": [18, 3], "code": "pos_bin_ind.allocate(xy.length);\nfor(auto p : xy)\n\tpos_bin_ind.write({p.x/spa_bin_size, p.y/spa_bin_size});", "name": "pos_bin_ind", "id": 19}, {"class_": "compute", "directBefore": [-1], "code": "timebase = parseInt(tet_file.header[\"timeabase\"]);\nint n_spikes = parseInt(tet_file.header[\"nump_spikes\"]);\ntimes.allocate(n_spikes);\nfor(auto c : tet_file.buffer.iter_blocks(216));\n\ttimes.write(c[0:4]);", "name": "spike_times", "id": 20}, {"class_": "compute", "directBefore": [-1], "code": "FileStreamer f(cut_file_name);\n// read cut header, which gets discarded\nint n_spikes = ??? header val;\ncut_file.allocate(n_spikes);\n\nwhile(auto buffer = f.read(BLOCK_SIZE){ \n\tfor(auto val in buffer.split('\\n'))\n\t\tcut_file.write(parseInt(val));\n}", "name": "cut_file", "id": 21}, {"class_": "input", "directBefore": [], "name": "tac_window_secs", "id": 22}]);    
    });
  </script>
  </body>
</html>