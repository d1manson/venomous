<?xml version="1.0" encoding="UTF-8" ?>
<document>
  <engine>
  
	<input name="axona_file_name" type="string"/>

	<compute name="axona_file">
		<arg name="axona_file_name"/>
		<return name="header" type="map"/>
		<return name="buffer" type="byte[]" chunking="manual"/>
		<description>
			Reads an axomna file which consists of a header block of multiple lines of: 
			```
			key_name [SPACE] key_value
			```
			Followed by a line that begins with the characters `"data_start"`.
			Following that is a (large) block of binary data.
			In some cases (set files) there may not be a `data_start` and binary_data section.
			This compute is aliased as `pos_file`, `set_file`, `tet_file`, and `eeg_file`.
		</description>
		<hints>disk=True</hints>
		<code><![CDATA[	
		
		const int BLOCK_SIZE = 2*1024*104; //2MB
		FileStreamer f(axona_file_name); //this is C++ RAII in action, we are using axona_file_name from its definition as an "input".
		int n_blocks = ceil(f.length()/BLOCK_SIZE); 
		if ( !computed(header) ){
			// we may already have this cached.
			map header_tmp;
			// parse f into header, storing the n_block, and data_start pointer as well
			header = header_tmp; 
		}

		for (block_ii in requested_blocks){
			buffer[block_ii] = f.read(block_ii*BLOCK_SIZE, BLOCK_SIZE);
		}

		]]></code>
	</compute>

	<alias name="pos_file_name" src="axona_file_name"/>
	<alias name="pos_file" src="axona_file">axona_file_name=pos_file_name</alias>

	<alias name="set_file_name" src="axona_file_name"/>
	<alias name="set_file" src="axona_file">axona_file_name=set_file_name</alias>

	<alias name="tet_file_name" src="axona_file_name"/>
	<alias name="tet_file" src="axona_file">axona_file_name=tet_file_name</alias>

	<alias name="eeg_file_name" src="axona_file_name"/>
	<alias name="eeg_file" src="axona_file">axona_file_name=eeg_file_name</alias>

	<raw><![CDATA[
		struct point{
		int16 x;
		int16 y;
		}
	]]></raw>

	<compute name="both_xy">
		<arg name="pos_file"/>
		<arg name="set_file"/>
		<return name="used_both" type="bool"/>
		<return name="xy1" type="point[]" chunking="10000"/>
		<return name="xy2" type="point[]" chunking="10000"/>
		<return name="w1" type="float"/>
		<return name="w2" type="float"/>
		<description>
			This takes the pos header and buffer and does the pos-post-processing, to produce either 1 or two
			arrays of points (only 1 if 1 LED was used).
		</description>
		<hints>CPU=1 CACHE=1 pos_file=all</hints>
		<code><![CDATA[	
		

		used_both = set_file.header['colactive_2']; 

		int num_samps = parseInt(pos_file.header['num_samps']);
		if (use_both){
			xy1.allocate(num_samps);
			xy2.allocate(num_samps);
			for(auto c pos_file.buffer.iter_blocks(16)){
				xy1.write(block[3]); // TODO: actual post processing..this is complicated for a number of reasons.
				xy2.write(block[4]);
			}	
		}else{
			xy_1.allocate(num_samps);
			for(auto c pos_file.buffer.iter_blocks(16))
				xy1.write(block[3]);
		}
		w1 = sum(!nan(xy1));
		w2 = sum(!nan(xy2)); 

		]]></code>
	</compute>

	<compute name="xy">
		<arg name="both_xy"/>
		<return name="xy" type="point[]" chunking="10000"/>
		<description>
			If there are two LEDs, this takes both sets of XY data and combines them to get a single value of xy for
			each moment in time.  with 1 LED, this simply uses that 1 array of XY data.
		</description>
		<hints>CPU=1 CACHE=1</hints>
		<code><![CDATA[		

		if(!both_xy.used_both){
			xy = both_xy.xy1;
		}else{
			xy.allocate(both_xy.xy1.length);
			for(auto p1, p2 : both_xy.xy1, both_xy.xy2)
				xy.write(p1*both_xy.w1 + p2*both_xy.w2);
		}

		]]></code>
	</compute>

	<raw><![CDATA[
		float angle_ab(point a, point b){
			auto dx = b.x - a.x;
			auto dy = b.y - a.y;
			return abs(dx) > 0.001 && abs(dy) > 0.001 ? atan2(dy,dx) : nan;
		}
	]]></raw>

	<compute name="dir">
		<arg name="both_xy" required=".used_both"/>
		<arg name="xy"/>
		<arg name="set_file"/>
		<return name="used_both" type="bool"/>
		<return name="dir_disp" type="float[]" chunking="10000"/>
		<return name="dir" type="float[]" chunking="10000"/>

		<description>
			The `used_both` is copied across from both_xy for convenience.
			If both LEDs are used then `dir!= dir_disp`, otherwise `dir` is `dir_disp`.
		</description>
		<hints>CPU=1 CACHE=1</hints>
		<code><![CDATA[	
		
		used_both = both_xy.used_both;
		dir_disp.allocate(xy.length);
		if(used_both){ 
			// TODO: could check which of the two dirs is requested and do different loop based on that. requested(dir_disp)
			dir.allocate(xy.length);
			point pw_old(nan,nan); 
			for(auto p1, p2, pw : both_xy.xy1, both_xy.xy2, xy){
				dir.write(angle_ab(p1,p2));
				dir_disp.write(angle_ab(pw,pw_old));
				pw_old = pw;	
			}
		}else{
			dir_disp.allocate(xy.length);
			dir.equals(dir_disp);
			point pw_old(nan,nan); 
			for(auto pw : xy){
				dir_disp.write(angle_ab(pw,pw_old));
				pw_old = pw;	
			}
		}

		]]></code>
	</compute>

	<compute name="speed">
		<arg name="xy"/>
		<arg name="pos_file" request=".header"/>
		<return type="int16[]" chunking="10000"/>

		<hints>CPU=1 CACHE=1</hints>
		<code><![CDATA[	
		
		int f = parseInt(pos_file.header['timebase']);
		speed.allocate(xy.length);
		point p_old (nan,nan);
		for(auto p : xy){
			speed.write(hypot(p_old.x - p.x, p_old.y - p.y) * f);
			p_old = p;
		}

		]]></code>
	</compute>

	

	<input name="group_num" type="uint8"/>

	<raw><![CDATA[
	template<typename T>
	struct spatial{
	float bin_size;
	int nW;
	int nH;
	vector<T> data; // length nW*nH
	}

	template<typename T>
	struct slice{
	T start;
	T end;
	}

	enum shape_type{
	rect;
	circle;
	}
	struct shape{
	shape_type kind;
	union shape{
		struct rect{
		int W:
		int H;
		point topleft;
		}
		struct circle{
		int R;
		point centre;
		}
	}
	}

	float boundary_dist_rect(point p, point topleft, int W, int H){
		auto v1 = p.x - topleft.x);
		auto v2 = topleft.x + W - p.x;
		auto v3 = p.y - topleft.y);
		auto v4 = topleft.y + H - p.y;
		return std::min(v1,v2,v3,v4);
	};

	]]></raw>

	<compute name="eeg">
		<arg name="eeg_file"/>
		<return type="int16[]" chunking="100000"/>
		<request name="timebase" type="int"/>
		<description>
			Simply pulls the eeg data from the file into an array, swapping endian-ness if need be.
		</description>
	</compute>

	<input name="eeg_freq_band_of_interest" type="slice^int^">
		<description>
			The low and high values in Hz. Theta is often treated as `6-12Hz`.
		</description>
	</input>

	<compute name="eeg_analytic">
		<arg name="eeg"/>
		<arg name="eeg_freq_band_of_interest"/>
		<return type="cint16[]" chunking="100000"/>
		<return type="int" name="timebase"/>
		<description>
			Bandpasses the eeg using a [Blackman window](https://en.wikipedia.org/wiki/Window_function#Blackman_windows) and then performs the [hilbert transform](https://en.wikipedia.org/wiki/Hilbert_transform) to get a complex (ie. `x +iy`) value for each time point.

			Note `timebase` is copied through from `eeg` for convenience.
		</description>
	</compute>

	<compute name="eeg_phase">
		<arg name="eeg_analytic"/>
		<return type="int16[]" chunking="100000"/>
		<return type="int" name="timebase"/>
		<description>
			Simply gives the complex angle of the analytic signal.

			Note `timebase` is copied through from `eeg` for convenience.
		</description>
	</compute>

	<compute name="eeg_power">
		<arg name="eeg_analytic"/>
		<return type="int16[]" chunking="100000"/>
		<return type="int" name="timebase"/>
		<description>
			Simply gives the complex magnitude of the analytic signal.

			Note `timebase` is copied through from `eeg` for convenience.
		</description>
	</compute>	

	<compute name="eeg_power_spectrum">
		<arg name="eeg"/>
		<return type="int16[]" chunking="100"/>
		<description>
			Peforms a Fourier transform, probably using the Fast method (unless a particularly small spectral window is needed in which case it might be better to use a naive DFT).
		</description>
	</compute>

	<input name="eeg_total_freq_band" type="slice^int^">
		<description>
			When computing signal-to-noise we ignore noise outside this range. Specified in Hz.
		</description>
	</input>

	<compute name="freq_band_sig_to_noise">
		<arg name="eeg_total_freq_band"/>
		<arg name="eeg_freq_band_of_interest"/>
		<arg name="eeg_power_spectrum" required="{{ chunks accoring to eeg_freq_band_of_interest }}"/>
		<return type="float"/>
		<description>
			Finds peak in the spectrum, within the `eeg_freq_band_of_interest`. Then computes the energy in the spectrum 
			1Hz either side of this, and normalizes by the average energy in `eeg_total_freq_band`.
		</description>
	</compute>

	<input name="trial_time_slice" type="slice^int32^"/> 
	<input name="directional_slice" type="slice^float^"/>
	<input name="spatial_mask" type="spatial^bool^"/>
	<input name="boundary_dist_slice" type="slice^float^"/>

	<input name="boundary_shape" type="shape"/>

	<compute name="dist_to_boundary">
		<return type="float[]" chunking="10000"/>
		<arg name="xy"/>
		<arg name="boundary_shape"/>

		<code><![CDATA[

		// might want to implement it as dist_to_boundary squared..although that only makes sense for circle not square 
		// so the details are a bit more complicated.
		dist_to_boundary.allocate(xy.length);
		if(boundary_shape.kind == circle){
			for(auto p : xy)
				dist_to_boundary.write( hypot(p.x-boundary_shape.shape.centre.x, p.y-boundary_shape.shape.centre.y));
		}else{ // boundary_shape.kind == rect
			for(auto p : xy)
				dist_to_boundary.write( boundary_dist_rect(p, boundary_shape.shape.topleft, boundary_shape.shape.W, boundary_shape.shape.H));
		}

		]]></code>
	</compute>

	<raw><![CDATA[
		enum logical_summary{
		// recrods the stat of a bool vector: either all true, none true, or a mixture of true and false.
		all; 
		none;
		mixture;
		}

		logical_summary make_logical_summary(bool[] X){
	   		if(all(X))
	   			return all;
	   		else if(none(X))
	   			return none;
	   		else
	   			return mixture;
		}
	]]></raw>
	<compute name="pos_mask">
		<return name="summary" type="logical_summary"/>
		<return name="mask" type="bool[]"/>
		<arg name="pos_file" request=".header"/>
		<arg name="trial_time_slice" optional="true"/>
		<arg name="directional_slice" optional="true"/>
		<arg name="spatial_mask" optional="true"/>
		<arg name="boundary_dist_slice" optional="true"/>
		<arg name="dist_to_boundary" optional="true"/>
		
		<description>
			`True` means use pos, `False` means don't use it.
			Computes a mask using zero or more of four differnt possible speicifications.
			Check `summary` to see if the mask is all-`False`, or all-`True`.  
			Note that you might want to have something even more complciated in terms of adding, subtracting and multiple slices.
			Not sure how easy that would be to implement in any framework, psoup or otherwise...well it might be ok in python actually.
		</description>
		<code><![CDATA[
		if(!isnull(trial_time_slice)  ||
		   !isnull(directional_slice) ||
		   !isnull(spatial_mask)	  ||
		   !isnull(boundary_dist_slice)){

		   	   // some kind of masking has been requested
		   	   if(!computed(mask)){
				   // we may already have computed mask, (in which case we are supposed to compute summary)
				   	   	   
				   vector<bool> tmp = array(pos_file.header["num_samps"]);
				   
				   if(!isnull(trial_time_slice)){
				   		tmp[:trial_time_slice.start = False;
				   		tmp[trial_time_slice.end:] = False;
				   }

				   if(!isnull(directional_slice)){
						tmp[!(directional_slice.start < dir[1] < directional_slice.end)] = False;
				   }

				   if(!isnull(boundary_dist_slice)){
						tmp[!(boundary_dist_slice.start < dist_to_boundary < boundary_dist_slice.end)] = False;
				   }

				   //TODO: implement spatial mask

				   mask = tmp;

			   }
			   if(requested(summary))
			   		summary = make_logical_summary(mask);

		   }else{
			   summary = all; //mask is all-true, so don't actually need to make it
		   }
		]]></code>
	</compute>

	<input name="speed_bin_size" type="float">
		<description>cm/s</description>
	</input>

	<raw><![CDATA[

		vector<int32> hist(vals, bin_size){
			vector<int32> h; // TODO: behind the scenes we need to decide how to deal with dynamically 
							 //resizing vector, which will reach a final state by the time the function returns.
			for(int i=0;i <vals.length;i++)
				h[vals[i]/bin_size]++;
			return h;
		}

		vector<int32> hist_masked(vals, mask, bin_size){
			vector<int32> h;
			for(int i=0;i <vals.length;i++) if(mask[i])
				h[vals[i]/bin_size]++
			return h;
		}
	]]></raw>

	<compute name="speed_dwell">
		<return type="int32[]"/>
		<arg name="speed"/>
		<arg name="pos_mask"/>
		<arg name="speed_bin_size"/>
		<code><![CDATA[
		if(pos_mask.summary == all)
			speed_dwell = hist(speed, speed_bin_size);
		else
			speed_dwell = hist_masked(speed, pos_mask, speed_bin_size);
		]]></code>
	</compute>

	<input name="spa_bin_size" type="float">
		<description>cm</description>
	</input>

	<compute name="pos_bin_ind">
		<return type="point[]" chunking="10000"/>
		<arg name="spa_bin_size"/>
		<arg name="xy"/>
		<code><![CDATA[
			pos_bin_ind.allocate(xy.length);
			for(auto p : xy)
				pos_bin_ind.write({p.x/spa_bin_size, p.y/spa_bin_size});
		]]></code>
	</compute>

	<compute name="spike_times">
		<return name="timebase" type="int"/>
		<return name="times" type="int32[]" chunking="10000"/>
		<arg name="tet_file"/>
		<description>returns spike times in same units as `tet_file` stored them</description>
		<code><![CDATA[
			timebase = parseInt(tet_file.header["timeabase"]);
			int n_spikes = parseInt(tet_file.header["nump_spikes"]);
			times.allocate(n_spikes);
			for(auto c : tet_file.buffer.iter_blocks(216));
				times.write(c[0:4]);

		]]></code>
	</compute>

	<compute name="waves">
		<arg name="tet_file"/>
		<return type="int8[]" chunking="200*5000"/>
		<description>
			The wave data for a spike is `50` samples on each of the `4` channels within a tetrode, i.e. `200` samples.  Each
			sample is one byte.

			*Optimization note:* we chunk data for 5,000 spikes together, using the serialised shape of the file on disk, i.e.
			even though the data is 3 dimensional, it is only accessible in 1d form, so we lose little by chunking in the same
			way...actually that's not quite true when it comes to discarding data, but we'll ignore that for now.
		</description>
	</compute>


	<compute name="wave_amplitude">
		<arg name="waves"/>
		<return type="uint8[]" chunking="5000"/>
		<description>
			Simply gives the `max-min` for each channel's spike.

			Note we store all the data for each channel contiguously (unlike in the `waves` array).
		</description>
	</compute>

	<compute name="wave_energy">
		<arg name="waves"/>
		<return type="uint8[]" chunking="5000"/>
		<description>
			Simply gives the `sum` for each channel's spike...well actually, I can't remember exactly how it's normaly defined.

			Note we store all the data for each channel contiguously (unlike in the `waves` array).
		</description>
	</compute>

	<input name="sub_spike_t" type="int8">
		<description>
			The index on the interval `[0,50)`, giving the time of interest within a spike.
		</description>
	</input>

	<compute name="wave_v_time_t">
		<arg name="waves"/>
		<arg name="sub_spike_t"/>
		<return type="uint8[]" chunking="5000"/>
		<description>
			Simply indexes into the `waves` as requested by `sub_spike_t`.

			Note we store all the data for each channel contiguously (unlike in the `waves` array).
		</description>
	</compute>



	<compute name="spike_pos_inds">
		<arg name="pos_file" required=".header"/>
		<arg name="spike_times"/>
		<return type="uint32[]" chunking="10000"/>
		<code><![CDATA[
			// read timebases to get factor and apply to spike times
		]]></code>
	</compute>

	<compute name="spike_mask">
		<arg name="pos_mask"/>
		<arg name="spike_pos_inds"/>
		<return name="summary" type="logical_summary"/>
		<return name="mask" type="bool[]"/>
		<code><![CDATA[
			//lookup spike pos inds in pos mask..use sorted_access_iterator
		]]></code>
	</compute>

	<alias name="cut_file_name" src="axona_file_name"/>

	<compute name="cut_file">
		<arg name="cut_file_name"/>
		<return type="uint8[]" chunking="10000"/>
		<code><![CDATA[

		FileStreamer f(cut_file_name);
		// read cut header, which gets discarded
		int n_spikes = ??? header val;
		cut_file.allocate(n_spikes);

		while(auto buffer = f.read(BLOCK_SIZE){ 
			for(auto val in buffer.split('\n'))
				cut_file.write(parseInt(val));
		}

		]]></code>
	</compute>

	<input name="tac_window_secs" type="float"/>

	<loop name="cut_changes_loop">
		<description>
			One of the main usage cases of the program is to modify the cluster assignments, which can be thought of as a bit like
			drawing stuff in Paint in so far as you use one or more tools to modify a "canvas" and expect to see the changes reflected
			in that canvas.  You also want to be able to undo your actions (with ideally a long undo-stack, rather than just a single
			stored previous state).

			Here, we start with either a blank cut or a cut loaded from file. Each "iteration" of the loop then consits of a "delta"
			which provides the modification information which could be a swap, or merge, or split, or transfer.

			 
		</description>
		<raw><![CDATA[
			struct cut_delta_enum{
				split_v_t;
				merge;
				swap;
				paint;
			}
			struct cut_delta_spec{
				cut_delta_enum kind;
				union{
				//stuff;
				}
			}
		]]></raw>

		<input name="cut_delta" type="cut_delta_spec"/>
		
		<compute name="cut_state">
			<arg name="cut_delta"/>
			<arg name="cut_changes_loop" required=".cut_inds"/>
			<arg name="cut_file" required="first_iteration"/>
			<arg name="waves" required="maybe"/>
			<arg name="amps" required="maybe"/>
			<return name="group_nums" type="uint8[]"/>
			<return name="inds_by_group" type="uint8[]" chunking="manual explicit"/>
			<description>
				On the first iteration of cut_changes_loop it reads from cut_file, on subsequent iterations
				it reads the pervious version of itself, i.e. cut_changes_loop.old_state.
				Each iteration of the loop is defined by its cut_delta.  This compute applies the delta
				to the the previous state to produce the current state.
			</description>
			<code><![CDATA[
				uint8[] inds;
				// need to do check whether the whole thing is required or only group nums
				// actually I think we are only going to want group nums
				if(cut_changes_loop.is_first_iteration)
					old_state = cut_file;
				else
					old_state = cut_changes_loop.cut_state.group_nums; // self on previous iteration

				switch(cut_delta.kind){
					case split_v_t:
						// do stuff with waves
						break;
					case paint:
						// do stuff with amps
						break;
					case swap:
						// do stuff simly with cut_inds 
						break;
					case swap:
						// do stuff simply with cut_inds
						break;
				}  
				cut_inds = inds;
			]]></code>
		</compute>

	</loop>
	
	<compute name="group_mask">
		<arg name="cut_state" required=".inds_by_group[group_num]"/>
		<arg name="spike_mask"/>
		<return name="summary" type="logical_summary"/>
		<return name="mask" type="bool[]"/>
		<code><![CDATA[
			if(!computed(group_mask))
				group_mask = copy(spike_mask.iter_sorted_inds(cut_state.inds_by_group[group_num]));
			if(required(summary))
				summary = make_logical_summary(group_mask);
		]]></code>
	</compute>

	<compute name="group_times_unmaksed">
		<arg name="group_num"/>
		<arg name="cut_state" required=".inds_by_group[group_num]"/>
		<arg name="spike_times"/>	
		<code><![CDATA[
			group_times_unmaksed = copy(spike_times.iter_sorted_inds(cut_state.inds_by_group[group_num]));
		]]></code>
	</compute>

	<compute name="group_times">
		<arg name="group_mask"/>
		<arg name="group_times_unmaksed"/>
		<return type="uint32[]"/>

		<code><![CDATA[
			if(group_mask.all)
				group_times.equals(group_times_unmaksed);
			if(group_mask.none)
				group_times = [];

			group_times = group_times_unmaksed[group_mask]; // TODO: implement logical take
		]]></code>
	</compute>

	<compute name="group_pos_inds_unmasked">
		<arg name="group_num"/>
		<arg name="cut_state" required=".inds_by_group[group_num]"/>
		<arg name="spike_pos_inds"/>
		<return type="uint32[]"/>
		<code><![CDATA[
			group_pos_inds_unmasked = copy(spike_pos_inds.iter_sorted_inds(cut_state.inds_by_group[group_num]));
		]]></code>
	</compute>

	<compute name="group_pos_inds">
		<arg name="group_pos_inds_unmasked"/>
		<arg name="group_mask"/>
		<return type="uint32[]"/>
		<code><![CDATA[
			if(group_mask.all)
				group_pos_inds.equals(group_pos_inds_unmasked);
			if(group_mask.none)
				group_pos_inds = [];

			group_pos_inds = group_pos_inds_unmaksed[group_mask]; // TODO: implement logical take
		]]></code>
	</compute>

	<compute name="tac">
		<arg name="group_times"/>
		<arg name="tac_window_secs"/>
		<return name="tac" type="float[]"/>
		<return name="max" type="uint32"/>
		<code><![CDATA[
			N_BINS = 100;
			uint32[] hist(N_BINS);
			float f = tac_window_secs * group_times.timebase /N_BINS;
			auto max_diff = tac_window_secs * group_times.timebase;
			auto later_time = group_times.times; //iterator
			for(auto earlier_time : group_times.times){
				// move the later time until it is one element beyond the end of the window
				for(;later_time < earlier_time + max_diff && later_time != group_times.times.end(); ++later_time) ;
				// accumulate a "1" in the histogram for each time in the window, relative to the earlier time.
				for( auto mid_time = earlier_time; mid_time != later_time; ++mid_time)
					hist[(mid_time-earlier_time)*f]++;
			}
			max = maximum(hist);
			float[] hist_normed(N_BINS);
			for(int i=0;i<N_BINS;i++)
				hist_normed[i] = hist[i] / max;
			tac = hist_normed;
		]]></code>
	</compute>

	<compute name="group_speed_hist">
		<arg name="group_pos_inds"/>
		<arg name="speed_bin_size"/>
		<arg name="speed_dwell"/>
		<arg name="speed"/>
		<return type="float[]"/>
		<return name="max" type="float"/>
		<description>
			Computes rate in each speed bin, normalises to max of 1, but also provides max rate in Hz.
		</description>
		<code><![CDATA[
			uint32[] spike;
			for(auto s : speed.iter_sorted(group_pos_inds))
				spike[speed/speed_bin_size]++;
			float[] rate = array(spike.length);
			for(int i=0; i< spike.length; i++)
				rate[i] = spike[i] / speed_dwell[i];
			max = maximum(rate);
			for(int i=0;i<rate.length;i++)
				rate[i] /= max;
			group_speed_hist = rate;
		]]></code>
	</compute>

</engine>
  <layout>
    <box name="axona_file_name" left="651" top ="-227" />
    <box name="group_num" left="1080" top ="567" />
    <box name="eeg_freq_band_of_interest" left="-151" top ="260" />
    <box name="eeg_total_freq_band" left="-397" top ="276" />
    <box name="trial_time_slice" left="970" top ="225" />
    <box name="directional_slice" left="1136" top ="289" />
    <box name="spatial_mask" left="1134" top ="234" />
    <box name="boundary_dist_slice" left="1043" top ="182" />
    <box name="boundary_shape" left="746" top ="244" />
    <box name="speed_bin_size" left="504" top ="550" />
    <box name="spa_bin_size" left="223" top ="271" />
    <box name="sub_spike_t" left="1928" top ="125" />
    <box name="tac_window_secs" left="1184" top ="981" />
    <box name="axona_file" left="661" top ="-66" />
    <box name="both_xy" left="367" top ="126" />
    <box name="xy" left="353" top ="219" />
    <box name="dir" left="426" top ="365" />
    <box name="speed" left="619" top ="321" />
    <box name="eeg" left="-62" top ="154" />
    <box name="eeg_analytic" left="54" top ="324" />
    <box name="eeg_phase" left="189" top ="438" />
    <box name="eeg_power" left="-43" top ="442" />
    <box name="eeg_power_spectrum" left="-268" top ="209" />
    <box name="freq_band_sig_to_noise" left="-274" top ="335" />
    <box name="dist_to_boundary" left="805" top ="305" />
    <box name="pos_mask" left="993" top ="376" />
    <box name="speed_dwell" left="648" top ="599" />
    <box name="pos_bin_ind" left="284" top ="331" />
    <box name="spike_times" left="1337" top ="106" />
    <box name="waves" left="1700" top ="92" />
    <box name="wave_amplitude" left="1511" top ="182" />
    <box name="wave_energy" left="1685" top ="181" />
    <box name="wave_v_time_t" left="1848" top ="178" />
    <box name="spike_pos_inds" left="1328" top ="202" />
    <box name="spike_mask" left="1285" top ="459" />
    <box name="cut_file" left="1283" top ="-43" />
    <box name="group_mask" left="1271" top ="807" />
    <box name="group_times_unmaksed" left="895" top ="634" />
    <box name="group_times" left="1063" top ="923" />
    <box name="group_pos_inds_unmasked" left="1086" top ="675" />
    <box name="group_pos_inds" left="1135" top ="735" />
    <box name="tac" left="1159" top ="1037" />
    <box name="group_speed_hist" left="855" top ="907" />
    <box name="cut_changes_loop" left="1383" top="538" width ="419" height="215">
      <box name="cut_delta" left="278" top ="38" />
      <box name="cut_state" left="111" top ="94" />
    </box>
    <offset left="4832" top="4847" />
  </layout>
</document>